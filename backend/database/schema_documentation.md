# Database Schema Documentation

## Overview

The GWorkspace Analyzer database is designed for high-performance invoice scanning, duplicate detection, and subscription tracking. It uses PostgreSQL (via Supabase) with Row Level Security (RLS) for multi-tenant isolation.

## Architecture Principles

1. **Multi-tenant**: Organization-level data isolation via `org_id`
2. **Security-first**: RLS policies on all user-accessible tables
3. **Performance**: Strategic indexes for common query patterns
4. **Scale**: Separate `invoice_content` table for large text data
5. **Audit trail**: Complete logging of user actions

## Tables

### Core Tables

#### `organizations`
Business organizations using the app. Each organization represents a company/domain.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `name` | TEXT | Organization name |
| `google_domain` | TEXT | Google Workspace domain (unique) |
| `subscription_tier` | ENUM | 'free', 'pro', 'enterprise' |
| `trial_ends_at` | TIMESTAMP | When free trial expires |
| `settings` | JSONB | Org-wide settings |

**Indexes:**
- `idx_organizations_domain` on `google_domain`

---

#### `users`
Individual users, linked to Supabase Auth.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key, references `auth.users(id)` |
| `email` | TEXT | User email (unique) |
| `org_id` | UUID | References `organizations(id)` |
| `google_token_vault_id` | UUID | Reference to Supabase Vault (secure token storage) |
| `last_scan_at` | TIMESTAMP | Last successful scan |
| `scan_count` | INTEGER | Total scans performed |
| `preferences` | JSONB | User preferences (alert thresholds, excluded vendors) |

**Indexes:**
- `idx_users_org` on `org_id`
- `idx_users_email` on `email`

**Security Note:** Google refresh tokens MUST be stored in Supabase Vault, not in this table. The `google_token_vault_id` is a reference only.

---

#### `scan_jobs`
Tracks Gmail scanning jobs with progress monitoring.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `user_id` | UUID | Who initiated the scan |
| `org_id` | UUID | Organization |
| `status` | ENUM | 'queued', 'processing', 'completed', 'failed' |
| `start_date` | DATE | Scan date range start |
| `end_date` | DATE | Scan date range end |
| `total_emails` | INTEGER | Total emails to process |
| `processed_emails` | INTEGER | Emails processed so far |
| `invoices_found` | INTEGER | Invoices extracted |
| `error_message` | TEXT | Error details if failed |

**Indexes:**
- `idx_scan_jobs_user` on `user_id, created_at DESC`
- `idx_scan_jobs_status` on `status` (partial index for active jobs)

**Use case:** Display scan progress in UI, retry failed scans.

---

#### `invoices`
Parsed invoice data from Gmail emails.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `org_id` | UUID | Organization |
| `user_id` | UUID | User who scanned this invoice |
| `scan_job_id` | UUID | Related scan job |
| `gmail_message_id` | TEXT | Gmail message ID (unique per org) |
| `gmail_thread_id` | TEXT | Gmail thread ID |
| `email_subject` | TEXT | Email subject line |
| `email_from` | TEXT | Sender email |
| `vendor_name` | TEXT | Extracted vendor name |
| `vendor_name_normalized` | TEXT | Lowercase, no special chars (for matching) |
| `invoice_number` | TEXT | Invoice/receipt number |
| `amount` | DECIMAL(12,2) | Invoice amount |
| `currency` | TEXT | Currency code (USD, EUR, etc.) |
| `invoice_date` | DATE | Invoice date |
| `due_date` | DATE | Payment due date |
| `line_items` | JSONB | Array of line items |
| `attachment_urls` | JSONB | Array of attachment URLs in Supabase Storage |
| `confidence_score` | DECIMAL(3,2) | Extraction confidence (0.00 to 1.00) |
| `extraction_method` | TEXT | 'pdf_parser', 'ocr', 'html', 'structured_data' |

**Indexes:**
- `idx_invoices_org_date` on `org_id, invoice_date DESC` (dashboard queries)
- `idx_invoices_gmail_msg` on `gmail_message_id` (upserts)
- `idx_invoices_vendor` on `org_id, vendor_name_normalized, invoice_date` (vendor analysis)
- `idx_invoices_duplicate_check` on `org_id, vendor_name_normalized, amount, invoice_date` (duplicate detection)
- `idx_invoices_line_items` GIN index on `line_items` (JSONB queries)

**Unique constraint:** `(org_id, gmail_message_id)` - one invoice per Gmail message per org

**Normalization:** `vendor_name_normalized` is auto-generated by trigger for consistent matching.

---

#### `invoice_content`
Large text content separated for performance (1:1 with invoices).

| Column | Type | Description |
|--------|------|-------------|
| `invoice_id` | UUID | Primary key, references `invoices(id)` |
| `raw_text` | TEXT | Extracted plain text |
| `raw_html` | TEXT | Original HTML (if applicable) |
| `extracted_data` | JSONB | Structured data extraction |

**Why separate?** Keeps `invoices` table fast for queries. Only fetch content when needed.

---

### Analysis Tables

#### `findings`
Detected issues: duplicates, price increases, unused subscriptions.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `org_id` | UUID | Organization |
| `type` | ENUM | 'duplicate', 'price_increase', 'unused_subscription', 'anomaly' |
| `status` | ENUM | 'pending', 'resolved', 'ignored' |
| `amount` | DECIMAL(12,2) | Financial impact (waste amount) |
| `currency` | TEXT | Currency code |
| `primary_invoice_id` | UUID | Main invoice related to finding |
| `title` | TEXT | Finding title (e.g., "Duplicate charge from AWS") |
| `description` | TEXT | Detailed description |
| `details` | JSONB | Additional finding-specific data |
| `confidence_score` | DECIMAL(3,2) | Detection confidence (0.00 to 1.00) |
| `resolved_by` | UUID | User who resolved/ignored |
| `resolved_at` | TIMESTAMP | Resolution timestamp |
| `user_notes` | TEXT | User-added notes |

**Indexes:**
- `idx_findings_org_status` on `org_id, status, created_at DESC` (dashboard)
- `idx_findings_type` on `type, status` (filtered queries)
- `idx_findings_amount` on `org_id, amount DESC` WHERE `status='pending'` (top savings)

**Usage:**
- Dashboard shows total waste: `SELECT SUM(amount) FROM findings WHERE status='pending'`
- Finding cards: `SELECT * FROM findings WHERE org_id=? ORDER BY amount DESC`

---

#### `finding_invoices`
Junction table linking findings to multiple invoices (M:N relationship).

| Column | Type | Description |
|--------|------|-------------|
| `finding_id` | UUID | References `findings(id)` |
| `invoice_id` | UUID | References `invoices(id)` |

**Primary key:** `(finding_id, invoice_id)`

**Example:** A duplicate finding references 2+ invoices with same charge.

---

#### `vendors`
Aggregated vendor tracking and subscription detection.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `org_id` | UUID | Organization |
| `name` | TEXT | Vendor display name |
| `name_normalized` | TEXT | Normalized name (auto-generated) |
| `aliases` | TEXT[] | Known name variations |
| `first_seen` | DATE | First invoice date |
| `last_seen` | DATE | Most recent invoice date |
| `total_invoices` | INTEGER | Total invoice count |
| `total_spent` | DECIMAL(12,2) | Lifetime spend |
| `avg_invoice_amount` | DECIMAL(12,2) | Average invoice amount |
| `is_subscription` | BOOLEAN | Detected as recurring subscription |
| `billing_frequency` | TEXT | 'monthly', 'quarterly', 'annual', 'one-time' |
| `is_excluded` | BOOLEAN | User excluded from analysis |
| `notes` | TEXT | User notes |

**Indexes:**
- `idx_vendors_org` on `org_id, last_seen DESC`
- `idx_vendors_subscription` on `org_id, is_subscription` (partial index)

**Unique constraint:** `(org_id, name_normalized)`

**Updates:** Updated via trigger/scheduled job after new invoices are added.

---

### Audit & Logging

#### `audit_log`
Complete audit trail of user actions for compliance and debugging.

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key |
| `user_id` | UUID | Who performed the action |
| `org_id` | UUID | Organization |
| `action` | TEXT | Action type ('finding_resolved', 'vendor_excluded', etc.) |
| `entity_type` | TEXT | What was modified ('finding', 'invoice', 'vendor') |
| `entity_id` | UUID | ID of modified entity |
| `changes` | JSONB | Before/after values |
| `metadata` | JSONB | Additional context |

**Indexes:**
- `idx_audit_log_org` on `org_id, created_at DESC`
- `idx_audit_log_user` on `user_id, created_at DESC`

**Example log entry:**
```json
{
  "action": "finding_resolved",
  "entity_type": "finding",
  "entity_id": "abc-123",
  "changes": {
    "status": {"from": "pending", "to": "resolved"}
  },
  "metadata": {
    "resolution_reason": "contacted vendor, refund issued"
  }
}
```

---

## Views

### `dashboard_summary`
Pre-aggregated dashboard metrics for fast loading.

```sql
SELECT * FROM dashboard_summary WHERE org_id = ?;
```

Returns:
- `pending_findings` - Total pending issues
- `duplicate_count`, `price_increase_count`, `unused_subscription_count` - Counts by type
- `total_waste` - Total money wasted (pending findings)
- `duplicate_waste`, `price_increase_waste`, `subscription_waste` - Waste by type

### `recent_invoices`
Invoices with vendor subscription info joined.

```sql
SELECT * FROM recent_invoices WHERE org_id = ? LIMIT 20;
```

---

## Row Level Security (RLS)

All tables have RLS enabled. Users can only access data from their own organization.

**Key policies:**
- `organizations`: SELECT/UPDATE own org
- `users`: SELECT/UPDATE own user record
- `invoices`: SELECT/INSERT own org's invoices
- `findings`: SELECT/UPDATE own org's findings
- `vendors`: SELECT/UPDATE own org's vendors

**Admin bypass:** Backend service can use `service_role` key to bypass RLS.

---

## Triggers

### Auto-updated timestamps
`updated_at` automatically updated on:
- `organizations`
- `users`
- `findings`
- `vendors`

### Vendor name normalization
`vendor_name_normalized` auto-generated on INSERT/UPDATE:
- `invoices` table
- `vendors` table

**Normalization logic:** Lowercase + remove all non-alphanumeric chars

Example: `"Amazon Web Services, Inc."` â†’ `"amazonwebservicesinc"`

---

## Performance Considerations

### Query Patterns

**Dashboard load:**
```sql
-- Use view for aggregates
SELECT * FROM dashboard_summary WHERE org_id = ?;

-- Get top findings
SELECT * FROM findings
WHERE org_id = ? AND status = 'pending'
ORDER BY amount DESC LIMIT 10;
```

**Duplicate detection:**
```sql
-- Uses idx_invoices_duplicate_check
SELECT * FROM invoices
WHERE org_id = ?
  AND vendor_name_normalized = ?
  AND amount = ?
  AND invoice_date BETWEEN ? AND ?;
```

**Vendor spending trends:**
```sql
-- Uses idx_invoices_vendor
SELECT
  DATE_TRUNC('month', invoice_date) as month,
  SUM(amount) as total
FROM invoices
WHERE org_id = ? AND vendor_name_normalized = ?
GROUP BY month
ORDER BY month DESC;
```

### Scaling Strategies

1. **Partitioning**: If >1M invoices, partition `invoices` table by `invoice_date`
2. **Archiving**: Move old invoices (>2 years) to archive table
3. **Caching**: Cache `dashboard_summary` view results (5 min TTL)
4. **Read replicas**: Use Supabase read replicas for analytics queries

---

## Security Checklist

- [x] RLS enabled on all tables
- [x] Users linked to `auth.users`
- [x] No plaintext tokens stored
- [x] Audit log for compliance
- [x] Unique constraints prevent duplicates
- [x] Cascading deletes configured

---

## Migration Strategy

### Adding columns (backwards compatible):
```sql
ALTER TABLE invoices ADD COLUMN new_field TEXT;
```

### Removing columns (requires app update):
```sql
-- Step 1: Deploy app that doesn't use old_field
-- Step 2: Run migration
ALTER TABLE invoices DROP COLUMN old_field;
```

### Data migrations:
```sql
-- Use transactions
BEGIN;
-- migration steps
COMMIT;
```

---

## Common Queries

### Get user's total waste
```sql
SELECT SUM(amount)
FROM findings
WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND status = 'pending';
```

### Get duplicate findings for a vendor
```sql
SELECT f.*, fi.invoice_id
FROM findings f
JOIN finding_invoices fi ON f.id = fi.finding_id
WHERE f.org_id = ? AND f.type = 'duplicate'
  AND f.primary_invoice_id IN (
    SELECT id FROM invoices WHERE vendor_name_normalized = ?
  );
```

### Get subscription vendors
```sql
SELECT * FROM vendors
WHERE org_id = ? AND is_subscription = true
ORDER BY total_spent DESC;
```

### User action history
```sql
SELECT * FROM audit_log
WHERE user_id = auth.uid()
ORDER BY created_at DESC
LIMIT 50;
```

---

## Future Enhancements

1. **Materialized views**: For faster dashboard queries
2. **Time-series data**: Separate table for spending trends over time
3. **ML features table**: Store invoice embeddings for better duplicate detection
4. **Notifications table**: Track email/push notifications sent
5. **Integrations table**: Connect to other tools (Slack, QuickBooks, etc.)
